# -*- coding: utf-8 -*-
"""Time_Series_Forecast_Sparkling.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17lVn7F5tCADEfR5JD4a_a7UxNshJn5ET
"""

from google.colab import files

# upload a file
upload = files.upload()

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd

import matplotlib.pyplot as plt
# %matplotlib inline

import seaborn as sns

from statsmodels.tsa.seasonal import seasonal_decompose

from sklearn.linear_model import LinearRegression

from statsmodels.tsa.api import SimpleExpSmoothing, Holt, ExponentialSmoothing

from sklearn.metrics import root_mean_squared_error

sparkling_df = pd.read_csv('Sparkling.csv', parse_dates = ['YearMonth'], index_col = ['YearMonth'] )
sparkling_df

sparkling_df.info()

sparkling_df[sparkling_df['Sparkling'].isna() == True]

"""* sparkling_df has no missing values"""

plt.figure(figsize = (10, 4))
sparkling_df['Sparkling'].plot()
plt.xlabel('YearMonth')
plt.ylabel('Sparkling Wine Sales')
plt.grid()
plt.title('Sparkling wine sales across the years')
plt.show()

"""* The sparkling wine sales shows level, no trend but seasonality."""

sparkling_df.describe()

sparkling_additive_decompose = seasonal_decompose(sparkling_df, model = 'additive', period = 12)

sparkling_additive_decompose.trend.head(10)

sparkling_additive_decompose.seasonal.head(10)

sparkling_additive_decompose.resid.head(10)

plt.figure(figsize = (10, 6))
sparkling_additive_decompose.plot()
plt.show()

"""**Additive decomposition of the sparkling wine sales -**
  * The sparkling wine sales has varying trend (downward trend till 1983 followed by upward trend till 1986 followed by a downward trend till 1987 followed by upward trend till 1989 followed by downward trend till 1990 followed by no such uptrend or downtrend) and exhibits seasonality.
  * The resid (error component) exhibits some influence of the systemic component (seasonality).
"""

sparkling_multiplicative_decompose = seasonal_decompose(sparkling_df, model = 'multiplicative', period = 12)

sparkling_multiplicative_decompose.trend.head(10)

sparkling_multiplicative_decompose.seasonal.head(10)

sparkling_multiplicative_decompose.resid.head(10)

plt.figure(figsize = (10, 6))
sparkling_multiplicative_decompose.plot()
plt.show()

"""**Multiplicative decomposition of the sparkling wine sales -**
  * The sparkling wine sales has varying trend (downward trend till 1983 followed by upward trend till 1986 followed by a downward trend till 1987 followed by upward trend till 1989 followed by downward trend till 1990 followed by no such uptrend or downtrend) and exhibits seasonality.
  * The resid (error component) is almost flat as compared to the resid of additive decomposition model.

**Conclusion** : Multiplicative model is the correct decomposition of the rosesparkling wine sales  
"""

sparkling2_df = sparkling_df.copy()

sparkling2_df['Sparkling'] = np.log(sparkling_df)

plt.subplot(2, 1, 1)
plt.plot(sparkling_df)
plt.title("Original sales of sparkling wine")

plt.subplot(2, 1, 2)
plt.plot(sparkling2_df)
plt.title("Log transform sales of sparkling wine")

plt.tight_layout()

plt.show()

#Dividing rose_df into train and test set

sparkling_train_df = sparkling_df[:'1990-12-01']
sparkling_test_df = sparkling_df['1991-01-01':]

sparkling_train_df

sparkling_test_df

train_time = [i+1 for i in range (len(sparkling_train_df))]
test_time = [len(sparkling_train_df)+1+i for i in range (len(sparkling_test_df))]

sparkling_train_df['time'] = train_time
sparkling_train_df

sparkling_test_df['time'] = test_time
sparkling_test_df

sparkling_train_lr = sparkling_train_df.copy()
sparkling_test_lr = sparkling_test_df.copy()

"""**Linear Regression for predicting the future sparkling wine sales**"""

# Linear Regression

lr = LinearRegression()
lr.fit(sparkling_train_lr[['time']], sparkling_train_lr['Sparkling'])

lr_test_prediction = lr.predict(sparkling_test_lr[['time']])
sparkling_test_lr['lr_test_prediction'] = lr_test_prediction
sparkling_test_lr

plt.figure(figsize = (12, 5))
plt.plot(sparkling_train_lr['Sparkling'], label = 'Train_Data')
plt.plot(sparkling_test_lr['Sparkling'], label = 'Test_Data')
plt.plot(sparkling_test_lr['lr_test_prediction'], label = 'Test_Prediction using linear regression')
plt.title('Sparkling wine sales distribution')
plt.legend(loc = 'best')
plt.show()

rmse_lr_test = root_mean_squared_error(sparkling_test_lr['Sparkling'], sparkling_test_lr['lr_test_prediction'])

error_df = pd.DataFrame({'Prediction_error_on_Test_Data': [rmse_lr_test]}, index = ['Linear Regression'])
error_df

"""**Predicting the future wine sales using the simple average**"""

# Simple Average

sparkling_sa_train = sparkling_train_df.copy()
saparkling_sa_test = sparkling_test_df.copy()

saparkling_sa_test['Simple_Average_Prediction'] = sparkling_sa_train['Sparkling'].mean()
saparkling_sa_test

plt.figure(figsize = (12, 5))
plt.plot(sparkling_sa_train['Sparkling'], label = 'Train_Data')
plt.plot(saparkling_sa_test['Sparkling'], label = 'Test_Data')
plt.plot(saparkling_sa_test['Simple_Average_Prediction'], label = 'Test_Prediction using simple mean')
plt.title('Sparkling wine sales distribution')
plt.legend(loc = 'best')
plt.show()

rmse_sa_test = root_mean_squared_error(saparkling_sa_test['Sparkling'], saparkling_sa_test['Simple_Average_Prediction'])

error_sa = pd.DataFrame({'Prediction_error_on_Test_Data': [rmse_sa_test]}, index = ['Simple Average'])
error_sa

error_df = pd.concat([error_df, error_sa])
error_df

"""**Predicting the future wine sales using the moving average**"""

# Moving Average

sparkling_ma_df = sparkling_df.copy()
sparkling_ma_df

sparkling_ma_df['Trailing_Moving_Average_2'] = sparkling_ma_df['Sparkling'].rolling(2).mean()
sparkling_ma_df['Trailing_Moving_Average_4'] = sparkling_ma_df['Sparkling'].rolling(4).mean()
sparkling_ma_df['Trailing_Moving_Average_6'] = sparkling_ma_df['Sparkling'].rolling(6).mean()
sparkling_ma_df['Trailing_Moving_Average_8'] = sparkling_ma_df['Sparkling'].rolling(8).mean()
sparkling_ma_df['Trailing_Moving_Average_10'] = sparkling_ma_df['Sparkling'].rolling(10).mean()
sparkling_ma_df

sparkling_ma_train_df = sparkling_ma_df[:'1990-12-01']
sparkling_ma_test_df = sparkling_ma_df['1991-01-01':]

plt.figure(figsize = (12, 5))
plt.plot(sparkling_ma_train_df['Sparkling'], label = 'Train Data')
plt.plot(sparkling_ma_test_df['Sparkling'], label = 'Test Data')
plt.plot(sparkling_ma_test_df['Trailing_Moving_Average_2'], label = 'Prediction using 2 place trailing moving average')
plt.plot()
plt.title('Sparkling wine sales distribution')
plt.legend(loc = 'best')
plt.show()

rmse_ma_2_test = root_mean_squared_error(sparkling_ma_test_df['Sparkling'], sparkling_ma_test_df['Trailing_Moving_Average_2'])
error_2_tma = pd.DataFrame({'Prediction_error_on_Test_Data': [rmse_ma_2_test]}, index = ['2 Place Trailing Moving Average'])
error_df = pd.concat([error_df, error_2_tma])
error_df

plt.figure(figsize = (12, 5))
plt.plot(sparkling_ma_train_df['Sparkling'], label = 'Train Data')
plt.plot(sparkling_ma_test_df['Sparkling'], label = 'Test Data')
plt.plot(sparkling_ma_test_df['Trailing_Moving_Average_4'], label = 'Prediction using 4 place trailing moving average')
plt.plot()
plt.title('Sparkling wine sales distribution')
plt.legend(loc = 'best')
plt.show()

rmse_ma_4_test = root_mean_squared_error(sparkling_ma_test_df['Sparkling'], sparkling_ma_test_df['Trailing_Moving_Average_4'])
error_4_tma = pd.DataFrame({'Prediction_error_on_Test_Data': [rmse_ma_4_test]}, index = ['4 Place Trailing Moving Average'])
error_df = pd.concat([error_df, error_4_tma])
error_df

plt.figure(figsize = (12, 5))
plt.plot(sparkling_ma_train_df['Sparkling'], label = 'Train Data')
plt.plot(sparkling_ma_test_df['Sparkling'], label = 'Test Data')
plt.plot(sparkling_ma_test_df['Trailing_Moving_Average_6'], label = 'Prediction using 6 place trailing moving average')
plt.plot()
plt.title('Sparkling wine sales distribution')
plt.legend(loc = 'best')
plt.show()

rmse_ma_6_test = root_mean_squared_error(sparkling_ma_test_df['Sparkling'], sparkling_ma_test_df['Trailing_Moving_Average_6'])
error_6_tma = pd.DataFrame({'Prediction_error_on_Test_Data': [rmse_ma_6_test]}, index = ['6 Place Trailing Moving Average'])
error_df = pd.concat([error_df, error_6_tma])
error_df

plt.figure(figsize = (12, 5))
plt.plot(sparkling_ma_train_df['Sparkling'], label = 'Train Data')
plt.plot(sparkling_ma_test_df['Sparkling'], label = 'Test Data')
plt.plot(sparkling_ma_test_df['Trailing_Moving_Average_8'], label = 'Prediction using 8 place trailing moving average')
plt.plot()
plt.title('Sparkling wine sales distribution')
plt.legend(loc = 'best')
plt.show()

rmse_ma_8_test = root_mean_squared_error(sparkling_ma_test_df['Sparkling'], sparkling_ma_test_df['Trailing_Moving_Average_8'])
error_8_tma = pd.DataFrame({'Prediction_error_on_Test_Data': [rmse_ma_8_test]}, index = ['8 Place Trailing Moving Average'])
error_df = pd.concat([error_df, error_8_tma])
error_df

plt.figure(figsize = (12, 5))
plt.plot(sparkling_ma_train_df['Sparkling'], label = 'Train Data')
plt.plot(sparkling_ma_test_df['Sparkling'], label = 'Test Data')
plt.plot(sparkling_ma_test_df['Trailing_Moving_Average_10'], label = 'Prediction using 10 place trailing moving average')
plt.plot()
plt.title('Sparkling wine sales distribution')
plt.legend(loc = 'best')
plt.show()

rmse_ma_10_test = root_mean_squared_error(sparkling_ma_test_df['Sparkling'], sparkling_ma_test_df['Trailing_Moving_Average_10'])
error_10_tma = pd.DataFrame({'Prediction_error_on_Test_Data': [rmse_ma_10_test]}, index = ['10 Place Trailing Moving Average'])
error_df = pd.concat([error_df, error_10_tma])
error_df

plt.figure(figsize = (15, 7))
plt.plot(sparkling_ma_train_df['Sparkling'], label = 'Train Data')
plt.plot(sparkling_ma_test_df['Sparkling'], label = 'Test Data')
plt.plot(sparkling_ma_test_df['Trailing_Moving_Average_2'], label = '2 Place Trailing Moving Average')
plt.plot(sparkling_ma_test_df['Trailing_Moving_Average_4'], label = '4 Place Trailing Moving Average')
plt.plot(sparkling_ma_test_df['Trailing_Moving_Average_6'], label = '6 Place Trailing Moving Average')
plt.plot(sparkling_ma_test_df['Trailing_Moving_Average_8'], label = '8 Place Trailing Moving Average')
plt.plot(sparkling_ma_test_df['Trailing_Moving_Average_10'], label = '10 Place Trailing Moving Average')
plt.plot()
plt.title('Sparkling wine sales distribution')
plt.legend(loc = 'best')
plt.show()

"""**Exponential Smoothing**"""

sparkling_sm_train_df = sparkling_train_df.copy()
sparkling_sm_train_df.drop('time', axis = 1, inplace = True)
sparkling_sm_train_df

sparkling_sm_test_df = sparkling_test_df.copy()
sparkling_sm_test_df.drop('time', axis = 1, inplace = True)
sparkling_sm_test_df

# SimpleExpSmoothing

model_ses = SimpleExpSmoothing(sparkling_sm_train_df, initialization_method = 'estimated')
model_ses = model_ses.fit(optimized = True)
model_ses.params

"""* smoothing_level	= 0.0703 :
	* Controls how much weight is given to the most recent observation when updating the level.
	* A small value (~0.07) means the model updates the level very slowly, giving much more weight to the historical level than to recent data.
	* This is ideal when the data has a stable pattern with random noise.

* initial_level =	1763.93 :
	* This is the initial estimate of the level (starting point) of the time series before any updates.
	* It serves as the base value from which the model begins forecasting.

* smoothing_trend = nan :
	 * nan means that the trend component is not included.
	 * The model assumes the series has no consistent upward or downward slope over time.

* smoothing_seasonal = nan :
	 * nan indicates that the seasonality component is not included.
	 * The model assumes no repeating seasonal patterns.

"""

ses_predict = model_ses.forecast(steps = len(sparkling_sm_test_df))
ses_predict

sparkling_sm_test_df['ses_predict'] = ses_predict
sparkling_sm_test_df

plt.figure(figsize = (12, 5))
plt.plot(sparkling_sm_train_df['Sparkling'], label = 'Train Data')
plt.plot(sparkling_sm_test_df['Sparkling'], label = 'Test Data')
plt.plot(sparkling_sm_test_df['ses_predict'], label = 'Prediction using simple exponential smoothing prediction')
plt.plot()
plt.title('Sparkling wine sales distribution')
plt.legend(loc = 'best')
plt.show()

rmse_ses_test = root_mean_squared_error(sparkling_sm_test_df['Sparkling'], sparkling_sm_test_df['ses_predict'])
error_ses = pd.DataFrame({'Prediction_error_on_Test_Data': [rmse_ses_test]}, index = ['Simple Exponential Smoothing with smoothing_level: 0.07028781460389563'])
error_df = pd.concat([error_df, error_ses])
error_df

# Holt's Linear Trend Model

model_holt = Holt(sparkling_sm_train_df, initialization_method = 'estimated')
model_holt = model_holt.fit(optimized = True)
model_holt.params

"""* **smoothing_level = 0.665** :
    * Controls how much weight is given to the most recent observation when updating the level.
    * A value close to 1 means recent data heavily influence the level; a value closer to 0 gives more weight to older data.
    * Here, 66.5% of the weight is given to the newest data, making level updates moderately responsive.

* **initial_level = 1502.20** :
	* The starting point (baseline value) of the time series before any updates.
	* The model assumes the series started at this value.

* **smoothing_trend	= 0.0001** :
	* Controls how much weight is given to the new trend information.
	* A value of 0.0001 is extremely small, meaning the trend is almost fixed and not significantly updated over time.
	* The model relies mostly on the initial_trend for forecasting the future slope.

* **initial_trend = 74.87** :
	* The initial slope, or the rate of change, estimated at the beginning of the series.
	* The model starts by assuming the series grows by ~74.87 units per time step. Combined with smoothing_trend, this trend is updated (minimally, in this case) over time.

* **smoothing_seasonal = nan** :
	* Seasonality is not included in this model.
	* The model does not expect any repeating seasonal patterns in the data.






"""

holt_predict = model_holt.forecast(steps = len(sparkling_sm_test_df))
holt_predict

sparkling_sm_test_df['holt_predict'] = holt_predict
sparkling_sm_test_df

plt.figure(figsize = (12, 5))
plt.plot(sparkling_sm_train_df['Sparkling'], label = 'Train Data')
plt.plot(sparkling_sm_test_df['Sparkling'], label = 'Test Data')
plt.plot(sparkling_sm_test_df['holt_predict'], label = 'Holts Linear Trend Model')
plt.plot()
plt.title('Sparkling wine sales distribution')
plt.legend(loc = 'best')
plt.show()

rmse_holt_test = root_mean_squared_error(sparkling_sm_test_df['Sparkling'], sparkling_sm_test_df['holt_predict'])
error_holt = pd.DataFrame({'Prediction_error_on_Test_Data': [rmse_holt_test]}, index = ['Holts Linear Trend Model with smoothing_level: 0.6649 & smoothing_trend: 0.0001'])
error_df = pd.concat([error_df, error_holt])
error_df

# Holt Winters Seasonal Model(Triple Exponential Smoothing with Additive Trend & Additive Seasonality)

model_tes = ExponentialSmoothing(sparkling_sm_train_df, trend = 'additive', seasonal = 'additive', initialization_method = 'estimated')
model_tes = model_tes.fit(optimized = True)
model_tes.params

"""* **smoothing_level = 0.1113** :
  * Controls how much weight is given to the most recent data in updating the level component.
  * A value of ~0.11 means the level is updated slowly, giving more weight to the historical average than recent observations.

* **initial_level = 2356.58** :
  * The initial estimate of the level — the starting point of the time series.
  * All forecasts are built upon this base.

* **smoothing_trend = 0.0124** :
  * Controls the weight on updating the trend component.
  * A very small value (~0.012) means the trend changes very slowly over time and the model mostly relies on the initial trend.

* **initial_trend = -0.0185** :
  * The initial slope of the trend.
  * A small negative value indicates a very slight downward trend at the beginning of the series.

* **smoothing_seasonal = 0.4607** :
  * Controls how much the seasonal component is updated with each new observation.
  * A value of ~0.46 is moderately high, meaning the seasonal pattern is adaptively updated, but still considers past seasonal values.

* **initial_seasons	array([...]) = [-636.23, -722.98, -398.64, -473.43, -808.43, -815.35, -384.23, 73.00, -237.44, 272.33, 1541.38, 2590.08]** :
  * There are 12 values, indicating monthly seasonality.
  * Each value represents the estimated seasonal effect for a specific month.
  * These are additive adjustments that get added or subtracted from the forecast depending on the season (e.g., month).
"""

tes_predict = model_tes.forecast(steps = len(sparkling_sm_test_df))
tes_predict

sparkling_sm_test_df['tes_predict'] = tes_predict
sparkling_sm_test_df

plt.figure(figsize = (12, 5))
plt.plot(sparkling_sm_train_df['Sparkling'], label = 'Train Data')
plt.plot(sparkling_sm_test_df['Sparkling'], label = 'Test Data')
plt.plot(sparkling_sm_test_df['tes_predict'], label = 'Holts Winters Seasonal Model with Additive Trend & Seasonality')
plt.plot()
plt.title('Sparkling wine sales distribution')
plt.legend(loc = 'best')
plt.show()

rmse_tes_test = root_mean_squared_error(sparkling_sm_test_df['Sparkling'], sparkling_sm_test_df['tes_predict'])
error_tes = pd.DataFrame({'Prediction_error_on_Test_Data': [rmse_tes_test]}, index = ['Holts Linear Trend Model with smoothing_level: 0.11127217859992398, smoothing_trend : 01236078328796452 & smoothing_seasonal: 0.4607177642170641'])
error_df = pd.concat([error_df, error_tes])
error_df

# Holt Winters Seasonal Model(Triple Exponential Smoothing with Additive Trend & Multiplicative Seasonality)

model_tes_aam = ExponentialSmoothing(sparkling_sm_train_df, trend = 'additive', seasonal = 'multiplicative', initialization_method = 'estimated')
model_tes_aam = model_tes_aam.fit(optimized = True)
model_tes_aam.params

"""* **smoothing_level = 0.1112** :
  * Controls how quickly the level of the series responds to changes.
  * A value of 0.11 means the model updates the level slowly, smoothing out short-term fluctuations.

* **initial_level = 2356.53**	:
  * The starting point (base value) for the level of the time series before applying any updates or trends.

* **smoothing_trend = 0.0494** :
  * Controls how fast the trend component is updated.
  * A small value (~0.049) indicates a slow adjustment to changes in trend — the model trusts the original trend more than recent changes.

* **initial_trend = -9.44** :
  * The initial slope of the trend, indicating the data was decreasing at the rate of ~9.44 units per time period at the beginning.
  * A negative value = downward trend.

* **smoothing_seasonal = 0.3621** :
  * Controls how quickly the seasonal pattern is updated.
  * A value of ~0.36 is moderate, indicating the model adjusts seasonality moderately in response to new data.

* **initial_seasons	array([...]) = [0.71, 0.68, 0.91, 0.801, 0.66, 0.66, 0.89, 1.13, 0.92, 1.21, 1.87, 2.37]** :
  * This array holds seasonal indices for each time step in the seasonal cycle (likely 12 months).
  * Values around 1.0 suggest a multiplicative seasonal component, where each period's forecast is multiplied by these values to account for seasonal effects.
"""

tes_aam_predict = model_tes_aam.forecast(steps = len(sparkling_sm_test_df))
tes_aam_predict

sparkling_sm_test_df['tes_aam_predict'] = tes_aam_predict
sparkling_sm_test_df

plt.figure(figsize = (12, 5))
plt.plot(sparkling_sm_train_df['Sparkling'], label = 'Train Data')
plt.plot(sparkling_sm_test_df['Sparkling'], label = 'Test Data')
plt.plot(sparkling_sm_test_df['tes_aam_predict'], label = 'Holts Winters Seasonal Model with Additive Trend & Multiplicative Seasonality')
plt.plot()
plt.title('Sparkling wine sales distribution')
plt.legend(loc = 'best')
plt.show()

rmse_tes_aam_test = root_mean_squared_error(sparkling_sm_test_df['Sparkling'], sparkling_sm_test_df['tes_aam_predict'])
error_tes_aam = pd.DataFrame({'Prediction_error_on_Test_Data': [rmse_tes_aam_test]}, index = ['Holts Linear Trend Model with additive trend and multiplicative sesonal - smoothing_level: 0.11119949831569428, smoothing_trend : 0.049430920023313805 & smoothing_seasonal: 0.3620525701498937'])
error_df = pd.concat([error_df, error_tes_aam])
error_df.sort_values(by = 'Prediction_error_on_Test_Data', ascending = True)

"""**ARIMA Model**"""

from statsmodels.tsa.stattools import adfuller

from statsmodels.graphics.tsaplots import plot_acf, plot_pacf

sparkling3_train_df = sparkling_df[:'1990-12-01']
sparkling3_test_df = sparkling_df['1991-01-01':]

# Augmented Dickey Fuller Test

adtest = adfuller(sparkling3_train_df, regression = 'ct')

print(f"adfuller test statistics is {adtest[0]}")
print(f"adfuller test p-value is {adtest[1]}")
print(f"Number of lags used - {adtest[2]}")

"""* The ADF (Augmented Dickey-Fuller) test is a statistical test used to determine whether a time series is stationary or not.

* A time series is stationary if its Mean, Variance & Autocorrelation remain constant over time. In simple terms, stationary data does not have trends or seasonality, and its behavior stays consistent.

* The ADF test checks for a unit root in the time series.
  * If a unit root is present, the series is non-stationary.
  * If there is no unit root, the series is stationary.

* Hypotheses in ADF Test:
  * H0 : The series has a unit root which means that the series non-stationary.
  * H1 : The is no unit root which means that the series is stationary.


* Here P-value is 0.57 which is greater than 0.05, which means data is accepting the null hypothesis, which means data is non-stationary.
"""

# Performing one level of differencing to check whether the Time Series becomes stationary

adtest = adfuller(sparkling3_train_df.diff().dropna(), regression = 'ct')

print(f"adfuller test statistics is {adtest[0]}")
print(f"adfuller test p-value is {adtest[1]}")
print(f"Number of lags used - {adtest[2]}")

"""* Here P-value is 8.4792106555143e-11, which means we will be rejecting the null hypothesis. So data is stationary.

* Therefore d (degree of differencing to make the series stationary) = 1
"""

plot_acf(sparkling3_train_df.diff(), title='Sparkling wine sales training data autocorrelation',missing='drop')
plot_pacf(sparkling3_train_df.diff().dropna(),title='Sparkling wine sales training data partial autocorrelation',zero=False,method='ywmle')
plt.show()

"""From ACF & PACF plot :
  * Number of lag observations included (i.e., how many previous time steps are used to predict the current value) is 3. Therefore p = 3.

  *  Number of lagged forecast errors in the prediction forecast is 2. Therefore q = 2
"""

from statsmodels.tsa.arima.model import ARIMA

pdq = (3, 1, 2)

manual_ARIMA_model = ARIMA(sparkling3_train_df['Sparkling'], order = pdq).fit()

print(manual_ARIMA_model.summary())

print('ARIMA {} - AIC : {}'.format(pdq, manual_ARIMA_model.aic))

predicted_sparkling_wine_sales = manual_ARIMA_model.forecast(steps = len(sparkling3_test_df))
sparkling3_test_df['predicted_sparkling_wine_sales_using_arima_model'] = predicted_sparkling_wine_sales

sparkling3_test_df

plt.figure(figsize = (12, 5))
plt.plot(sparkling3_train_df['Sparkling'], label = 'Train Data')
plt.plot(sparkling3_test_df['Sparkling'], label = 'Test Data')
plt.plot(sparkling3_test_df['predicted_sparkling_wine_sales_using_arima_model'], label = 'Predicted sparkling wine sales using arima(3, 1, 2)')
plt.plot()
plt.title('Sparkling wine sales distribution')
plt.legend(loc = 'best')
plt.show()

rmse_manual_arima_test = root_mean_squared_error(sparkling3_test_df['Sparkling'], sparkling3_test_df['predicted_sparkling_wine_sales_using_arima_model'])
error_arima_aam = pd.DataFrame({'Prediction_error_on_Test_Data': [rmse_manual_arima_test]}, index = ['Predicted sparkling wine sales using arima model(p = 3, d = 1, q = 2)'])
error_df = pd.concat([error_df, error_arima_aam])
error_df.sort_values(by = 'Prediction_error_on_Test_Data', ascending = True)

"""**SARIMAX Model**"""

from statsmodels.tsa.statespace.sarimax import SARIMAX

manual_SARIMA_model = SARIMAX(sparkling3_train_df['Sparkling'], order=(3,1,2), seasonal_order=(0, 0, 3, 6)).fit(maxiter=1000)

print(manual_SARIMA_model.summary())

print('SARIMA (3, 1, 2)x(0, 0, 3, 6) - AIC : {}'.format(manual_SARIMA_model.aic))

predicted_sparkling_wine_sales = manual_SARIMA_model.forecast(steps = len(sparkling3_test_df))
sparkling3_test_df['predicted_sparkling_wine_sales_using_manual_sarima_model'] = predicted_sparkling_wine_sales

sparkling3_test_df

plt.figure(figsize = (12, 5))
plt.plot(sparkling3_train_df['Sparkling'], label = 'Train Data')
plt.plot(sparkling3_test_df['Sparkling'], label = 'Test Data')
plt.plot(sparkling3_test_df['predicted_sparkling_wine_sales_using_manual_sarima_model'], label = 'Predicted sparkling wine sales using sarima(3, 1, 2)(0, 0, 3, 6)')
plt.plot()
plt.title('Sparkling wine sales distribution')
plt.legend(loc = 'best')
plt.show()

rmse_manual_sarima_test = root_mean_squared_error(sparkling3_test_df['Sparkling'], sparkling3_test_df['predicted_sparkling_wine_sales_using_manual_sarima_model'])
error_arima_aam = pd.DataFrame({'Prediction_error_on_Test_Data': [rmse_manual_sarima_test]}, index = ['Predicted sparkling wine sales using manual sarima model(3, 1, 2)(0, 0, 3, 6)'])
error_df = pd.concat([error_df, error_arima_aam])
error_df.sort_values(by = 'Prediction_error_on_Test_Data', ascending = True)

"""**Auto ARIMA Model**"""

import itertools
p = q = range(0, 4)
d= range(1,2)
pdq = list(itertools.product(p, d, q))
print('Examples of the parameter combinations for the Arima model -')
for i in range(0,len(pdq)):
    print('Model: {}'.format(pdq[i]))

# Creating an empty Dataframe with column names only

ARIMA_AIC = pd.DataFrame(columns=['param', 'AIC'])
ARIMA_AIC

for param in pdq:
    auto_ARIMA_model = ARIMA(sparkling3_train_df['Sparkling'].values,order=param).fit()
    print('ARIMA{} - AIC:{}'.format(param, auto_ARIMA_model.aic))

pdq = (2, 1, 2)

auto_ARIMA_model = ARIMA(sparkling3_train_df['Sparkling'], order = pdq).fit()

print(auto_ARIMA_model.summary())

print('ARIMA {} - AIC : {}'.format(pdq, auto_ARIMA_model.aic))

predicted_sparkling_wine_sales = auto_ARIMA_model.forecast(steps = len(sparkling3_test_df))
sparkling3_test_df['predicted_sparkling_wine_sales_using_auto_arima_model'] = predicted_sparkling_wine_sales

sparkling3_test_df

plt.figure(figsize = (12, 5))
plt.plot(sparkling3_train_df['Sparkling'], label = 'Train Data')
plt.plot(sparkling3_test_df['Sparkling'], label = 'Test Data')
plt.plot(sparkling3_test_df['predicted_sparkling_wine_sales_using_auto_arima_model'], label = 'Predicted sparkling wine sales using auto arima(2, 1, 2)')
plt.plot()
plt.title('Sparkling wine sales distribution')
plt.legend(loc = 'best')
plt.show()

rmse_auto_arima_test = root_mean_squared_error(sparkling3_test_df['Sparkling'], sparkling3_test_df['predicted_sparkling_wine_sales_using_auto_arima_model'])
error_auto_arima = pd.DataFrame({'Prediction_error_on_Test_Data': [rmse_auto_arima_test]}, index = ['Predicted sparkling wine sales using auto arima model(p = 2, d = 1, q = 2)'])
error_df = pd.concat([error_df, error_auto_arima])
error_df.sort_values(by = 'Prediction_error_on_Test_Data', ascending = True)

"""Conclusion:

---


Among all models, **Holts Linear Trend Model with smoothing_level: 0.11, smoothing_trend : 0.12 & smoothing_seasonal: 0.46** is the best model having least prediction error on test data.
"""

# Training Holt Winters Seasonal Model(Triple Exponential Smoothing with Additive Trend & Additive Seasonality) with the entire data

model_tes = ExponentialSmoothing(sparkling_df, trend = 'additive', seasonal = 'additive', initialization_method = 'estimated')
model_tes = model_tes.fit(optimized = True)
model_tes.params

"""* **smoothing_level = 0.07597** :
  * Controls the weight of the most recent observation in updating the level.
  * A low value (~0.076) means the level is updated slowly, making the model less reactive to short-term fluctuations.

* **initial_level = 2356.50** :
    * The starting point (baseline) of the level component of the time series.
    * It anchors the forecast at the beginning.

* **smoothing_trend = 0.03257** :
    * Controls how fast the trend component is updated.
    * A small value (~0.033) means the trend changes slowly over time.
    * The model trusts the initial trend more than incoming trend changes.

* **initial_trend = -1.0367** :
    * The initial slope of the trend component.
    * A negative value implies a slight downward trend at the start of the series.

* **smoothing_seasonal = 0.3766** :
    * Controls how quickly the seasonal component is updated.
    * A moderate value (~0.38) implies the seasonal pattern is somewhat adaptive, adjusting with moderate responsiveness to new data.

* **initial_seasons	array([...]) =  [-636.25, -723.00, -398.67, -473.45, -808.43, -815.37, -384.25, 73.00, -237.46, 272.35, 1541.39, 2590.11]**:
    * Represents the initial estimates of seasonal effects for each period in a 12-period cycle (likely monthly seasonality).
    * These values are additive adjustments, added to the forecast depending on the period.
    * The values vary widely, indicating strong seasonal effects (e.g., from -815 to +2590).
"""

# Sparkling wine sales prediction for next 12 months.

tes_predict = model_tes.forecast(steps = 12)
tes_predict

plt.figure(figsize = (12, 5))
plt.plot(sparkling_df['Sparkling'], label = 'Sparkling wine sales')
plt.plot(tes_predict, label = 'Sparkling wine sale forecast for next 12 months.')
plt.title('Sparkling wine sales distribution')
plt.legend(loc = 'best')
plt.show()

