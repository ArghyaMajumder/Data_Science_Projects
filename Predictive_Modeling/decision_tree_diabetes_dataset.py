# -*- coding: utf-8 -*-
"""Decision_Tree_Diabetes_Dataset.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kvK3KRN6Wa8ISZg0oKU_2pSNII-0CGaW
"""

from google.colab import files

# upload a file
upload = files.upload()

# Commented out IPython magic to ensure Python compatibility.
import numpy as np

import pandas as pd

import matplotlib.pyplot as plt
# %matplotlib inline

import seaborn as sns

from sklearn import tree

from sklearn.tree import DecisionTreeClassifier, export_graphviz, plot_tree

from sklearn.ensemble import RandomForestClassifier

from sklearn.preprocessing import StandardScaler

from sklearn.model_selection import GridSearchCV

from sklearn.model_selection import train_test_split

from sklearn.metrics import roc_auc_score, roc_curve, classification_report, confusion_matrix

diabetes_df = pd.read_csv("Dataset_Diabetes_Diabetic_Data.csv")
diabetes_df

diabetes_df.info()

diabetes_df.isna().sum()

# Are there any duplicates ?

duplicate_rows = diabetes_df[diabetes_df.duplicated()]
num_duplicates = diabetes_df.duplicated().sum()
print("Total number of duplicate rows: ", num_duplicates)
duplicate_rows

print(f"The unique values of diabatic feature in diabetes_df - {diabetes_df['diabatic'].unique()}\n")

print(f"Count of the unique values of diabatic feature in diabetes_df - \n{diabetes_df['diabatic'].value_counts()}\n")

print(f"The distribution of diabatic feature in diabetes_df - \n{diabetes_df['diabatic'].value_counts(normalize = True)}")

plt.figure(figsize = (7, 4))
sns.histplot(x = 'diabatic', data = diabetes_df, binwidth = 0.5)
plt.grid(True)
plt.title('Count plot indicating number of patients suffering from diabetes')

"""* The "diabatic" column in the diabetes_df DataFrame indicates whether a patient is diabetic.
* Approximately 67% of the patients in the dataset are diabetic, while 33% are not.
"""

# Dropping the unwanted variable patient_nbr

diabetes_df.drop(["patient_nbr"], axis = 1, inplace = True)

print(f"The number of unique race are {diabetes_df['race'].nunique()}\n")

print(f"The unique values in race : \n{diabetes_df['race'].unique()}\n")

print(f"The Number of patients of each race : \n{diabetes_df['race'].value_counts()}\n")

print(f"The distributon of number of patients of each race : \n{diabetes_df['race'].value_counts(normalize = True)}\n")

plt.figure(figsize = (10, 4))
sns.histplot(x = 'race', data = diabetes_df, binwidth = 1)
plt.grid(True)
plt.title('Distribution of the race of a patient')

# Features - race has some unknown value '?'. Replacing '?' with nan

diabetes_df['race'] = diabetes_df['race'].replace(to_replace = '?',  value = np.nan)


#Deleting the rows containing nan

diabetes_df.dropna(inplace = True)

plt.figure(figsize = (10, 4))
sns.histplot(x = 'race', data = diabetes_df, hue = 'diabatic', multiple = 'dodge', binwidth = 1)
plt.grid(True)
plt.title('Distribution of the race of the patient')

"""* The 'race' feature describes the racial background of the patients. Initially, it included 'Caucasian', 'AfricanAmerican', '?', 'Other', 'Asian', and 'Hispanic'.

* 'Caucasian' is the predominant race, accounting for approximately 72.8% of patients, followed by 'AfricanAmerican' at about 21.4%, ? at about 2%, Hispanic at abouy 2%, Other at about 1%)and Asian (0.5%).

* Missing values, represented as '?', were initially present (around 2.1%) were removed.

* Diabetes prevalence across different racial groups .
"""

print(f"The number of unique values in gender are {diabetes_df['gender'].nunique()}\n")

print(f"The unique values in gender : \n{diabetes_df['gender'].unique()}\n")

print(f"Count of each unique values in gender : \n{diabetes_df['gender'].value_counts()}\n")

print(f"Distribution of the gender : \n{diabetes_df['gender'].value_counts(normalize = True)}\n")

# Features - gender has some unknown value 'Unknown/Invalid'. Replacing 'Unknown/Invalid' with nan

diabetes_df['gender'] = diabetes_df['gender'].replace(to_replace = 'Unknown/Invalid',  value = np.nan)


#Deleting the rows containing nan

diabetes_df.dropna(inplace = True)

plt.figure(figsize = (8, 3))
sns.histplot(x = 'gender', data = diabetes_df, binwidth = 1)
plt.grid(True)
plt.title('Distribution of the gender of the patient')

plt.figure(figsize = (8, 3))
sns.histplot(x = 'gender', data = diabetes_df, hue = 'diabatic', multiple = 'dodge', binwidth = 1)
plt.grid(True)
plt.title('Distribution of the gender for both diabetic and non diabetic patients')

"""* The 'gender' column in the diabetes_df DataFrame has three unique values: 'Female', 'Male', and 'Unknown/Invalid'.

* The dataset contains predominantly 'Female' (approximately 54.3%) and 'Male' (approximately 45.7%) patients.

* The dataset containing missing value, represented as 'Unknown/Invalid' was removed.

* Diabetes prevalence across different gender groups .
"""

print(f"The number of unique values in age are {diabetes_df['age'].nunique()}\n")

print(f"The unique values in : \n{diabetes_df['age'].unique()}\n")

print(f"Count of the patients of different : \n{diabetes_df['age'].value_counts()}\n")

print(f"Distribution of age of the patient : \n{diabetes_df['age'].value_counts(normalize = True)}\n ")

plt.figure(figsize = (10, 4))
sns.histplot(x = 'age', data = diabetes_df, binwidth = 1)
plt.grid(True)
plt.title('Distribution of the age of the patient')

plt.figure(figsize = (10, 4))
sns.histplot(x = 'age', data = diabetes_df, hue = 'diabatic', multiple = 'dodge', binwidth = 1)
plt.grid(True)
plt.title('Distribution of the age of both diabetic and non diabetic patient')

"""* This feature represents the age of patients in 10-year intervals (e.g., '[0-10)', '[10-20)', '[20-30)', '[30-40)', '[40-50)', '[50-60)', '[60-70)', '[70-80)', '[80-90)', [90-100)).

* The highest concentration of patients is in the '[70-80)' age group (around 25.8%), followed by '[60-70)' (around 21.7%), '[50-60)' (around 17.3%), [80-90) (around 16%), '[40-50)' (around 9.9%), '[30-40)' (around 4%), [90-100) (around 3%), '[20-30)' (around 1.7%), '[10-20)' (around 0.8%) and '[0-10)' (around 0.2%)

* Patients of age bracket [0-20) are few in number.

* Majority of patients of age 20 onwards are diabatic.
"""

print(f"The number of unique values in admission_type_id are: {diabetes_df['admission_type_id'].nunique()}\n")

print(f"The unique values in admission_type_id are: {diabetes_df['admission_type_id'].unique()}\n")

print(f"Count of the unique values in admission_type_id are {diabetes_df['admission_type_id'].value_counts()}")

print(f"Distribution of the unique values in admission_type_id are {diabetes_df['admission_type_id'].value_counts(normalize = True)}")

plt.figure(figsize = (10, 4))
sns.histplot(x = 'admission_type_id', data = diabetes_df, binwidth = 0.5)
plt.grid(True)
plt.title('Distribution of the type of admission')

plt.figure(figsize = (10, 4))
sns.histplot(x = 'admission_type_id', data = diabetes_df, hue = 'diabatic', multiple = 'dodge', binwidth = 1)
plt.grid(True)
plt.title('Distribution of the type of admission')

"""* 'admission_type_id' represents different types of admission. It has 8 unique integer values.

* The most common admission type is '1' (Emergency), accounting for approximately 51.0% of admissions, followed by type '2' (Urgent) at 18.7%, type '3' (Elective) at 17.4%, type '6' (NULL) at 6.6%, type '5' (Not Available) at 5.9%, type '8' (Not Mapped) at 0.2%, type '4' (Newborn) at 0.01% and type '7' (Trauma Center) at 0.01% .

* Patients having admission type - '1' (Emergency) and '5' (Not Available) are non diabatic whereas majority of patients having admission type - '2' (Urgent), '3' (Elective), '4' (Newborn), '6' (NULL), '7' (Trauma Center), '8' (Not Mapped) are diabatic.
"""

print(f"The number of unique values in discharge_disposition_id are: {diabetes_df['discharge_disposition_id'].nunique()}\n")

print(f"Unique values of discharge_disposition_id are: {diabetes_df['discharge_disposition_id'].unique()}\n")

print(f"Count of discharge_disposition_id :\n {diabetes_df['discharge_disposition_id'].value_counts()}\n")

print(f"Distribution of discharge_disposition_id in  :\n {diabetes_df['discharge_disposition_id'].value_counts(normalize = True)}\n")

plt.figure(figsize = (14, 5))
sns.histplot(x = 'discharge_disposition_id', data = diabetes_df, binwidth = 1)
plt.grid(True)
plt.title('Distribution of the type of discharge disposition')

plt.figure(figsize = (14, 4))
sns.histplot(x = 'discharge_disposition_id', data = diabetes_df, hue = 'diabatic', multiple = 'dodge', binwidth = 1)
plt.grid(True)
plt.title('Distribution of the type of discharge disposition')

"""* discharge_disposition_id indicates the circumstances of patient discharge, with 26 unique integer values.

* The most frequent discharge disposition is '1' (Discharged to home), representing about 59.0% of cases. Other common dispositions include '3' (Discharged/transferred to SNF) at 12.4% and '6' (Discharged/transferred to home with home health service) at 11.8%.

* Most diabetic patient's disposition is '1' (Discharged to home) followed by '3' (Discharged/transferred to SNF), '6' (Discharged/transferred to home with home health service), '11' (Expired), '22' (Discharged/transferred to another rehab fac including rehab units of a hospital), '5' (Discharged/transferred to another type of inpatient care institution) and '25' (Not Mapped)
"""

print(f"The number of unique values in admission_source_id are {diabetes_df['admission_source_id'].nunique()}\n")

print(f"The unique values in admission_source_id : {diabetes_df['admission_source_id'].unique()}\n")

print(f"Count of the unique values in admission_source_id : \n{diabetes_df['admission_source_id'].value_counts()}\n")

print(f"Distribution of admission_source : \n{diabetes_df['admission_source_id'].value_counts(normalize = True)}\n")

plt.figure(figsize = (15, 4))
sns.histplot(x = 'admission_source_id', data = diabetes_df, binwidth = 1)
plt.grid(True)
plt.title('Distribution of the type of admission')

plt.figure(figsize = (15, 4))
sns.histplot(x = 'admission_source_id', data = diabetes_df, hue = 'diabatic', multiple = 'dodge', binwidth = 1)
plt.grid(True)
plt.title('Distribution of the type of admission')

"""* This column identifies the source of admission, with 13 unique integer values.
* The most common admission source is '7' (Emergency Room), accounting for approximately 52.4% of admissions, followed by '1' (Physician Referral) at 29.2%, followed by '17' (NULL) at 9 %, followed by '4' (Transfer from a hospital) at 3.6%, followed by '2' (Clinic Referral) at 1.4%, followed by '5' (Transfer from a Skilled Nursing Facility (SNF)) at 1%.

* Most of the people having common admission source '7' (Emergency Room), '1' (Physician Referral), '17' (NULL), '4' (Transfer from a hospital), '2' (Clinic Referral), '5' (Transfer from a Skilled Nursing Facility (SNF)) are diabatic.

"""

print(f"The number of unique values in time_in_hospital are {diabetes_df['time_in_hospital'].nunique()}\n")

print(f"The unique values in time_in_hospital : \n{diabetes_df['time_in_hospital'].unique()}\n")

print(f"Count of the unique values in time_in_hospital : \n{diabetes_df['time_in_hospital'].value_counts()}\n")

print(f"Distribution of time_in_hospital : \n{diabetes_df['time_in_hospital'].value_counts(normalize = True)}")

plt.figure(figsize = (14, 5))
sns.histplot(x = 'time_in_hospital', data = diabetes_df, binwidth = 1)
plt.grid(True)
plt.title('Distribution of the number of days spend in hospital')

plt.figure(figsize = (12, 5))
sns.histplot(x = 'time_in_hospital', data = diabetes_df, hue = 'diabatic', multiple = 'dodge', binwidth = 1)
plt.grid(True)
plt.title('Distribution of the number of days spend in hospital')

"""* This numerical column represents the number of days a patient spent in the hospital, with 14 unique values ranging from 1 to 14 days.
* The most common durations are 2 days (approx. 16.9%) and 3 days (approx. 16.8% after NaN removal). The distribution shows a peak at lower durations and then gradually decreases.
* Most diabatic patients spend 3 days followed by 2, 4, 1, 5, 6, 7, 8, 9, 13, 10, 11, 12, 14 days in hospital.
"""

print(f"The number of unique values in num_lab_procedures are {diabetes_df['num_lab_procedures'].nunique()}\n")

print(f"The unique values in num_lab_procedures : \n{diabetes_df['num_lab_procedures'].unique()}\n")

print(f"Count of the unique values in num_lab_procedures : \n{diabetes_df['num_lab_procedures'].value_counts()}\n")

print(f"Distribution of num_lab_procedures : \n{diabetes_df['num_lab_procedures'].value_counts(normalize = True)}")

plt.figure(figsize = (20, 5))
sns.histplot(x = 'num_lab_procedures', data = diabetes_df, binwidth = 1)
plt.grid(True)
plt.title('Distribution of the number of lab tests performed during the stay in the hospital')

plt.figure(figsize = (20, 5))
sns.histplot(x = 'num_lab_procedures', data = diabetes_df, hue = 'diabatic', multiple = 'dodge', binwidth = 1)
plt.grid(True)
plt.title('Distribution of the number of lab tests performed during the stay in the hospital')

"""* This column indicates the number of lab tests performed, with 116 unique values.

* The distribution shows varying number of lab procedures performed on a patient are 43, 44, 1, 45, 38, 46, 39, 40, 47, 48 etc.

* For a diabatic patient number of lab procedures performed are 43, 44, 1, 45, 38, 46, 47, 39, 49 etc.

"""

print(f"The number of unique values in num_procedures are {diabetes_df['num_procedures'].nunique()}\n")

print(f"The unique values in num_procedures : \n{diabetes_df['num_procedures'].unique()}\n")

print(f"Count of the unique values in num_procedures : \n{diabetes_df['num_procedures'].value_counts()}\n")

print(f"Distribution of num_procedures : \n{diabetes_df['num_procedures'].value_counts(normalize = True)}\n")

plt.figure(figsize = (10, 4))
sns.histplot(x = 'num_procedures', data = diabetes_df, binwidth = 1)
plt.grid(True)
plt.title('Distribution of the number of procedures (other than lab tests) performed during the stay in the hospital')

plt.figure(figsize = (10, 4))
sns.histplot(x = 'num_procedures', data = diabetes_df, hue = 'diabatic', multiple = 'dodge', binwidth = 1)
plt.grid(True)
plt.title('Distribution of the number of procedures performed during the stay in the hospital for both diabetic and non diabetic')

"""* This column represents the number of procedures (other than lab tests) performed, with 7 unique values (0 to 6).

* A significant portion of patients had 0 procedures followed by 1, 2, 3, etc.

* A significant portion of diabatic patients had 0 procedures followed by 1, 2, 4, etc.

"""

print(f"The number of unique values in num_medications are {diabetes_df['num_medications'].nunique()}\n")

print(f"The unique values in num_medications : \n{diabetes_df['num_medications'].unique()}\n")

print(f"Count of the unique values in num_medications : \n{diabetes_df['num_medications'].value_counts()}\n")

print(f"Distribution of the num_medications : \n{diabetes_df['num_medications'].value_counts(normalize = True)}\n")

plt.figure(figsize = (18, 4))
sns.histplot(x = 'num_medications', data = diabetes_df, binwidth = 1)
plt.grid(True)
plt.title('Distribution of the number of distinct generic names administered during the encounter')

plt.figure(figsize = (18, 4))
sns.histplot(x = 'num_medications', data = diabetes_df, hue = 'diabatic', multiple = 'dodge', binwidth = 1)
plt.grid(True)
plt.title('Distribution of the number of distinct generic names administered to both diabetic and non diabetic during the encounter')

"""* This column indicates the number of distinct medications administered, with 74 unique values.

* Most of the patients had 12 distinct medications administered followed by 13, 11, 10, 14, 15, 9 etc.

* Most of the diabatic patients had 12 distinct medications administered followed by 13, 11, 14, 15, 16, 10, 17, 9 etc.
"""

print(f"The number of unique values in number_outpatient are {diabetes_df['number_outpatient'].nunique()}\n")

print(f"The unique values in number_outpatient : \n{diabetes_df['number_outpatient'].unique()}\n")

print(f"Count of the unique values in number_outpatient : \n{diabetes_df['number_outpatient'].value_counts()}\n")

print(f"Distribution of the unique values in number_outpatient : \n{diabetes_df['number_outpatient'].value_counts(normalize = True)}")

plt.figure(figsize = (10, 4))
sns.histplot(x = 'number_outpatient', data = diabetes_df, binwidth = 1)
plt.grid(True)
plt.title('Distribution of the number of outpatient visits of the patient in the year preceding the encounter')

plt.figure(figsize = (10, 4))
sns.histplot(x = 'number_outpatient', data = diabetes_df, hue = 'diabatic', multiple = 'dodge', binwidth = 1)
plt.grid(True)
plt.title('Distribution of the number of outpatient visits of the patient in the year preceding the encounter for both diabetic and non diabetic')

"""* This column records the number of outpatient visits in the year preceding the encounter, with 29 unique values.

* The vast majority of patients (approximately 85.7%) had 0 outpatient visits followed by 1, 2, 3, 4, 5 etc.

* Majority of diabatic patient also had 0 outpatient visits followed by 1, 2, 3, 4, 5 etc.

"""

print(f"The number of unique values in number_emergency are {diabetes_df['number_emergency'].nunique()}\n")

print(f"The unique values in number_emergency : {diabetes_df['number_emergency'].unique()}\n")

print(f"Count of the unique values in number_emergency : {diabetes_df['number_emergency'].value_counts()}\n")

print(f"Distribution of the unique values in number_emergency : \n{diabetes_df['number_emergency'].value_counts(normalize = True)}")

plt.figure(figsize = (10, 4))
sns.histplot(x = 'number_emergency', data = diabetes_df, binwidth = 1)
plt.grid(True)
plt.title('Distribution of the number of emergency visits of the patient in the year preceding the encounter')

plt.figure(figsize = (10, 4))
sns.histplot(x = 'number_emergency', data = diabetes_df, hue = 'diabatic', multiple = 'dodge', binwidth = 1)
plt.grid(True)
plt.title('Distribution of the number of emergency visits of the diabetic & non diabetic patient in the year preceding the encounter')

"""* This column shows the number of emergency visits in the year preceding the encounter, with 19 unique values.

* Similar to outpatient visits, vast majority of patients (approximately 90.4%) had 0 emergency visits followed by 1, 2, 3 etc.

* Similar to outpatient visits, vast majority of diabatic patients had 0 emergency visits followed by 1, 2, 3 etc.
"""

print(f"The number of unique values in number_inpatient are {diabetes_df['number_inpatient'].nunique()}\n")

print(f"The unique values in number_inpatient : \n{diabetes_df['number_inpatient'].unique()}\n")

print(f"Count of the unique values in number_inpatient : \n{diabetes_df['number_inpatient'].value_counts()}\n")

print(f"Distribution of the unique values in number_inpatient : \n{diabetes_df['number_inpatient'].value_counts(normalize = True)}")

plt.figure(figsize = (10, 4))
sns.histplot(x = 'number_inpatient', data = diabetes_df, binwidth = 1)
plt.grid(True)
plt.title('Distribution of the number of inpatient visits of the patient in the year preceding the encounter')

plt.figure(figsize = (10, 4))
sns.histplot(x = 'number_inpatient', data = diabetes_df, hue = 'diabatic', multiple = 'dodge', binwidth = 1)
plt.grid(True)
plt.title('Distribution of the number of inpatient visits of a diabetic and non diabetic patient in the year preceding the encounter')

"""* This column records the number of inpatient visits in the year preceding the encounter, with 21 unique values.

* Majority of patients (approximately 67.4%) had 0 emergency visits followed by 1, 2, 3, 4 etc.

* Majority of diabatic patients had 0 emergency visits followed by 1, 2, 3, 4 etc.
"""

print(f"The number of unique values in number_diagnoses are {diabetes_df['number_diagnoses'].nunique()}\n")

print(f"The unique values in number_diagnoses : \n{diabetes_df['number_diagnoses'].unique()}\n")

print(f"Count of the unique values in number_diagnoses : \n{diabetes_df['number_diagnoses'].value_counts()}\n")

print(f"Distribution of the number of diagnoses entered to the system for a patient : \n{diabetes_df['number_diagnoses'].value_counts(normalize = True)}")

plt.figure(figsize = (10, 4))
sns.histplot(x = 'number_diagnoses', data = diabetes_df, binwidth = 1)
plt.grid(True)
plt.title('Number of diagnoses a patient undergone')

plt.figure(figsize = (10, 4))
sns.histplot(x = 'number_diagnoses', data = diabetes_df, hue = 'diabatic', multiple = 'dodge', binwidth = 1)
plt.grid(True)
plt.title('Number of diagnoses a diabetic and non diabetic patient undergone')

"""* This column indicates the total number of diagnoses entered for the patient, with 16 unique values.

* Majority of patients (approximately 42.2%) had 9 diagnoses followed by 5, 6, 8, 7, 4 etc.

* Majority of diabatic patients had 9, 5, 8, 7, 6, 4 etc.
"""

print(f"The number of unique values in diag_1 are {diabetes_df['diag_1'].nunique()}\n")

print(f"The unique values in diag_1 : \n{diabetes_df['diag_1'].unique()}\n")

print(f"Count of the unique values in diag_1 : \n{diabetes_df['diag_1'].value_counts()}\n")

print(f"Distribution of diag_1 : \n{diabetes_df['diag_1'].value_counts(normalize = True)}\n")

# Replacing '?' with NaN

diabetes_df['diag_1'] = diabetes_df['diag_1'].replace(to_replace='?', value=np.nan)

# Remove rows with NaN values
diabetes_df.dropna(inplace=True)

grouped_by_diag1 = diabetes_df.groupby('diag_1')

# To iterate through the groups:
for name, group in grouped_by_diag1:
    print(f"group : {name}")

    group_by_diabetic = group.groupby('diabatic')
    for diabetic, group_1 in group_by_diabetic:
      print(f"Diabetic: {diabetic}, size : {group_1.shape[0]}")

    print("\n")

"""* This column represent the primary diagnoses, coded typically using ICD codes.

* diag_1 has 683 unique values, indicating a wide variety of primary diagnoses.

* Top 5 primary diagnoses are 414 (4821 tests performed), 428 (4757 tests performed), 786 (2989 tests performed), 410 (2541 tests performed), 486 (2303 tests performed).

* Results of primary diagnoses -
  * Test : 414 -
    Diabetic: No, count : 1494,
    Diabetic: Yes, count : 3327

  * Test : 428 -
    Diabetic: No, count : 1491,
    Diabetic: Yes, count : 3266

  * Test : 786 -
    Diabetic: No, count : 1062,
    Diabetic: Yes, count : 1927

  * Test : 410 -
    Diabetic: No, count : 782,
    Diabetic: Yes, count : 1759

  * Test : 486 -
    Diabetic: No, count : 640,
    Diabetic: Yes, count : 1663
"""

print(f"The number of unique values in diag_2 are {diabetes_df['diag_2'].nunique()}\n")

print(f"The unique values in diag_2 : \n{diabetes_df['diag_2'].unique()}\n")

print(f"Count of the unique values in diag_2 : \n{diabetes_df['diag_2'].value_counts()}\n")

print(f"Distribution of diag_2 : \n{diabetes_df['diag_2'].value_counts(normalize = True)}\n")

# Replacing '?' with NaN

diabetes_df['diag_2'] = diabetes_df['diag_2'].replace(to_replace='?', value=np.nan)

# Remove rows with NaN values
diabetes_df.dropna(inplace=True)

grouped_by_diag2 = diabetes_df.groupby('diag_2')

# To iterate through the groups:
for name, group in grouped_by_diag2:
    print(f"group : {name}")

    group_by_diabetic = group.groupby('diabatic')
    for diabetic, group_2 in group_by_diabetic:
      print(f"Diabetic: {diabetic}, size : {group_2.shape[0]}")

    print("\n")

"""* This column represent the secondary diagnoses coded typically using ICD codes.

* diag_2 has 701 unique values, indicating a wide variety of secondary diagnoses.

* Top 5 secondary diagnoses are 428 (4691 tests performed), 276 (4554 tests performed), 250 (4288 tests performed), 427 (3466 tests performed) & 401 (2639 tests performed).

* Results of secondary diagnoses -
  * Test : 428 -
    Diabetic: No, count : 1455,
    Diabetic: Yes, count : 3236

  * Test : 276 -
    Diabetic: No count : 1436,
    Diabetic: Yes, count : 3118

  * Test : 250 -
    Diabetic: No, count : 1391,
    Diabetic: Yes, count : 2897

  * Test : 427 -
    Diabetic: No, count : 1176,
    Diabetic: Yes, count : 2290

  * Test : 401 -
    Diabetic: No, count : 949,
    Diabetic: Yes, count : 1690
"""

print(f"The number of unique values in diag_3 are {diabetes_df['diag_3'].nunique()}\n")

print(f"The unique values in diag_3 : \n{diabetes_df['diag_3'].unique()}\n")

print(f"Count of the unique values in diag_3 : \n{diabetes_df['diag_3'].value_counts()}\n")

print(f"Distribution of diag_3 : \n{diabetes_df['diag_3'].value_counts(normalize = True)}\n")

diabetes_df['diag_3'] = diabetes_df['diag_3'].replace(to_replace = '?', value = np.nan)

diabetes_df.dropna(inplace = True)

grouped_by_diag3 = diabetes_df.groupby('diag_3')

# To iterate through the groups:
for name, group in grouped_by_diag3:
    print(f"group : {name}")

    group_by_diabetic = group.groupby('diabatic')
    for diabetic, group_3 in group_by_diabetic:
      print(f"Diabetic: {diabetic}, size : {group_3.shape[0]}")

    print("\n")

"""* This column represent the additional secondary diagnoses coded typically using ICD codes.

* diag_3 has 683 unique values, indicating a wide variety of additional secondary diagnoses.

* Top 5 additional secondary diagnoses are
250 (8075 tests performed), 401 (5887 tests performed), 276 (3301 tests performed), 428 (3158 tests performed) and 427 (2691 tests performed)

* Results of additional secondary diagnoses -
  * Test : 250 -
      Diabetic: No, count : 2651,
      Diabetic: Yes, count : 5424

  * Test : 401 -
      Diabetic: No, count : 1922,
      Diabetic: Yes, count : 3965

  * Test : 276 -
      Diabetic: No, count : 1050,
      Diabetic: Yes, count : 2251

  * Test : 428 -
      Diabetic: No, count : 930,
      Diabetic: Yes, count : 2228

  * Test : 427 -
      Diabetic: No, count : 883,
      Diabetic: Yes, count : 1808
"""

print(f"The number of unique values in change are {diabetes_df['change'].nunique()}\n")

print(f"The unique values in change : \n{diabetes_df['change'].unique()}\n")

print(f"Count of the unique values in change : \n{diabetes_df['change'].value_counts()}\n")

print(f"Distribution of the number of changes in the diabetic medications for a patient : \n{diabetes_df['change'].value_counts(normalize = True)}")

plt.figure(figsize = (6, 4))
sns.histplot(x = 'change', data = diabetes_df, binwidth = 1)
plt.grid(True)
plt.title('Count plot indicating if there was a change in diabetic medications (either dosage or generic name) of a patient')

plt.figure(figsize = (6, 4))
sns.histplot(x = 'change', data = diabetes_df, hue = 'diabatic', multiple = 'dodge', binwidth = 1)
plt.grid(True)
plt.title('Count plot indicating if there was a change in diabetic medications (either dosage or generic name) of both diabetic and non diabetic patient')

"""* This categorical column indicates if there was a change in diabetic medications ('Ch' for change, 'No' for no change).

* Majority of patients (approximately 62.6%) have no change in their diabatic medications.

* Majority of the diabatic patients had changes in their medications.
"""

# Are there any duplicates ?

dups = diabetes_df.duplicated()
print('Number of duplicate rows = %d' % (dups.sum()))
diabetes_df[dups]

diabetes_df.info()

diabetes_df[['time_in_hospital', 'num_lab_procedures', 'num_procedures', 'num_medications', 'number_outpatient','number_emergency', 'number_inpatient', 'number_diagnoses']].describe()

# construct box plot for continuous variables to check the presence of outliers

plt.figure(figsize = (12, 8))
sns.boxplot(data = diabetes_df[['time_in_hospital', 'num_lab_procedures', 'num_procedures', 'num_medications', 'number_outpatient', 'number_emergency', 'number_inpatient', 'number_diagnoses']], orient = 'h')
plt.title('Box plot to check for the presence of outliers')

# Handling outliers

for col in diabetes_df[['time_in_hospital', 'num_lab_procedures', 'num_procedures', 'num_medications', 'number_outpatient', 'number_emergency', 'number_inpatient', 'number_diagnoses']]:
  print(f"Column : {col}\n")
  # Calculate the upper and lower limits
  Q1 = diabetes_df[col].quantile(0.25)
  Q3 = diabetes_df[col].quantile(0.75)
  IQR = Q3 - Q1
  lower_limit = Q1 - 1.5*IQR
  upper_limit = Q3 + 1.5*IQR

  diabetes_df[col] = np.where(diabetes_df[col] < lower_limit, lower_limit, diabetes_df[col])
  diabetes_df[col] = np.where(diabetes_df[col] > upper_limit, upper_limit, diabetes_df[col])

# construct box plot for continuous variables to check the presence of outliers

plt.figure(figsize = (12, 8))
sns.boxplot(data = diabetes_df[['time_in_hospital', 'num_lab_procedures', 'num_procedures', 'num_medications', 'number_outpatient', 'number_emergency', 'number_inpatient', 'number_diagnoses']], orient = 'h')
plt.title('Box plot to check for the presence of outliers')

plt.figure(figsize = (10, 4))
sns.heatmap(diabetes_df[['time_in_hospital', 'num_lab_procedures', 'num_procedures', 'num_medications', 'number_inpatient', 'number_diagnoses']].corr(), annot = True)
plt.title('Heat map diplaying the correlation between the variables in the dataframe')

# Converting the object types to categorical types

for feature in diabetes_df.columns:
  if diabetes_df[feature].dtype == 'object':
    print(f"Converting feature : {feature} to categorical")
    print(pd.Categorical(diabetes_df[feature].unique()))
    print(pd.Categorical(diabetes_df[feature].unique()).codes)
    diabetes_df[feature] = pd.Categorical(diabetes_df[feature]).codes
    print(f"\n\n")

diabetes_df.head(10)

diabetes_df.info()

X = diabetes_df.drop('diabatic', axis = 1)
X

y = diabetes_df['diabatic']
y

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.3, random_state = 1)

print('X_train.shape: ', X_train.shape)
X_train

print('y_train.shape: ', y_train.shape)
y_train

print('X_test.shape: ', X_test.shape)
X_test

print('y_test.shape: ', y_test.shape)
y_test

"""**DecisionTree classifier**"""

dtcl = DecisionTreeClassifier(random_state=1)
dtcl.fit(X_train, y_train)

# dtcl model's prediction on training data

y_train_predict = dtcl.predict(X_train)
y_train_predict

# dtcl model's prediction on taining data

conf_train = pd.DataFrame(confusion_matrix(y_train, y_train_predict), columns = [['0', '1']], index = [['0', '1']])
conf_train

print(classification_report(y_train, y_train_predict))

# dtcl model's prediction probability on training data

y_train_predict_prob = dtcl.predict_proba(X_train)
y_train_predict_prob_pos = y_train_predict_prob[:, 1]
auc_score_train = roc_auc_score(y_train, y_train_predict_prob_pos)
print('auc_score of dtcl model on training data: ', auc_score_train)

fpr, tpr, thresholds = roc_curve(y_train, y_train_predict_prob_pos)

plt.plot([0, 1], [0, 1], linestyle = '--')
plt.plot(fpr, tpr, marker = '*')
plt.title('ROC curve of dtcl model on training data.')

# dtcl model's prediction on test data

y_test_predict = dtcl.predict(X_test)
y_test_predict

# dtcl model's prediction on test data

conf_test = pd.DataFrame(confusion_matrix(y_test, y_test_predict), columns = [['0', '1']], index = [['0', '1']])
conf_test

print(classification_report(y_test, y_test_predict))

# dtcl model's prediction probability on test data

y_test_predict_prob = dtcl.predict_proba(X_test)
y_test_predict_prob_pos = y_test_predict_prob[:, 1]
auc_score_test = roc_auc_score(y_test, y_test_predict_prob_pos)
print('auc_score of dtcl model on test data: ', auc_score_test)

fpr, tpr, thresholds = roc_curve(y_test, y_test_predict_prob_pos)

plt.plot([0, 1], [0, 1], linestyle = '--')
plt.plot(fpr, tpr, marker = '*')
plt.title('ROC curve of dtcl model on test data.')

print(pd.DataFrame(dtcl.feature_importances_, columns = ["Imp"], index = X_train.columns).sort_values('Imp', ascending = False))

# Decision tree visualization

from google.colab import drive

drive.mount('/content/drive')
file = open('/content/drive/My Drive/Colab Notebooks/diabatic_decision_tree.dot', 'w')
train_char_label = ['1', '0']
dot_data = export_graphviz(dtcl, out_file = file, feature_names = list(X_train), class_names = list(train_char_label))
file.close()

"""**Training Set Performance:**
1. The DecisionTree classifier model achieves an accuracy of 1.00 on the training set.
2. Metrics for exceptional both Class 0 (precision=1.00, recall=1.00, F1-score=1.00) and Class 1 (precision=1.00, recall=1.00, F1-score=1.00).
3. The ROC AUC score is 1.00, demonstrating exceptional predictive power.

**Test Set Performance:**
1. On the test set, the accuracy drops to 0.71 .
2. Class 0 metrics are poor (precision=0.56, recall=0.57, F1-score=0.56), while class 1 metrics are moderate (precision=0.78, recall=0.78, F1-score=0.78).
3. The ROC AUC score is 0.67, demonstrating weak predictive power.

**Analysis:** The DecisionTree classifier exhibits overfitting and requires extensive tuning to generalize well.

**Regularized dtcl classifier**
"""

# Regularized dtcl classifier

param_grid = {
    'criterion': ['gini'],
    'max_depth': [10,20,30,50],
    'min_samples_leaf': [50,100,150],
    'min_samples_split': [150,300,450],
}


grid_search = GridSearchCV(estimator = dtcl, param_grid = param_grid, cv = 10)
grid_search.fit(X_train, y_train)
print(grid_search.best_params_)
best_grid = grid_search.best_estimator_
best_grid

# Regularized dtcl model's prediction on training data

y_train_predict = best_grid.predict(X_train)
y_train_predict

# Regularized dtcl model's performance on taining data

conf_train = pd.DataFrame(confusion_matrix(y_train, y_train_predict), columns = [['0', '1']], index = [['0', '1']])
conf_train

print(classification_report(y_train, y_train_predict))

# Regularized dtcl model's prediction probability on training data

y_train_predict_prob = best_grid.predict_proba(X_train)
y_train_predict_prob_pos = y_train_predict_prob[:, 1]
auc_score_train = roc_auc_score(y_train, y_train_predict_prob_pos)
print('auc_score of regularized dtcl model on training data: ', auc_score_train)

fpr, tpr, thresholds = roc_curve(y_train, y_train_predict_prob_pos)

plt.plot([0, 1], [0, 1], linestyle = '--')
plt.plot(fpr, tpr, marker = '*')
plt.title('ROC curve of regularized dtcl model on training data.')

# Regularized dtcl model's prediction on test data

y_test_predict = best_grid.predict(X_test)
y_test_predict

# Regularized dtcl model's performance on test data

conf_test = pd.DataFrame(confusion_matrix(y_test, y_test_predict), columns = [['0', '1']], index = [['0', '1']])
conf_test

print(classification_report(y_test, y_test_predict))

# Regularized dtcl model's prediction probability on test data

y_test_predict_prob = best_grid.predict_proba(X_test)
y_test_predict_prob_pos = y_test_predict_prob[:, 1]
auc_score_test = roc_auc_score(y_test, y_test_predict_prob_pos)
print('auc_score of regularized dtcl model on test data: ', auc_score_test)

fpr, tpr, thresholds = roc_curve(y_test, y_test_predict_prob_pos)

plt.plot([0, 1], [0, 1], linestyle = '--')
plt.plot(fpr, tpr, marker = '*')
plt.title('ROC curve of regularized dtcl model on test data.')

# Regularized Decision tree visualization


file = open('/content/drive/My Drive/Colab Notebooks/diabatic_regularized_decision_tree.dot', 'w')
train_char_label = ['1', '0']
dot_data = export_graphviz(best_grid, out_file = file, feature_names = list(X_train), class_names = list(train_char_label))
file.close()

"""**Training Set Performance:**
1. The regularized DecisionTree classifier model achieves an accuracy of 0.76 on the training set.
2. Class 0 metrics are weak (precision=0.62, recall=0.73, F1-score=0.67), while Class 1 metrics are robust (precision=0.85, recall=0.77, F1-score=0.81),
3. The ROC AUC score is 0.85, demonstrating strong predictive power.

**Test Set Performance:**
1. On the test set, the accuracy remains steady at 0.74 .
2. Class 0 metrics are weak (precision=0.59, recall=0.72, F1-score=0.65), while class 1 metrics are moderate (precision=0.84, recall=0.75, F1-score=0.79).
3. The ROC AUC score is 0.83, demonstrating strong predictive power.

**Analysis:** The regularized DecisionTree classifier maintains consistent performance across training and test sets, suggesting good generalization capabilities.

**Random Forest**
"""

rfcl = RandomForestClassifier(random_state = 1)

rfcl.fit(X_train, y_train)

# rfcl model classification on train set

y_train_predict = rfcl.predict(X_train)
y_train_predict

# rfcl model performance on train set

cm_train = pd.DataFrame(confusion_matrix(y_train, y_train_predict), columns = [0, 1], index = [0, 1])
cm_train

print(classification_report(y_train, y_train_predict))

y_train_predict_prob = rfcl.predict_proba(X_train)
y_train_predict_prob_pos = y_train_predict_prob[:, 1]
roc_score = roc_auc_score(y_train, y_train_predict_prob_pos)

print('roc_auc_score of rfcl on train data: {}'.format(roc_score))

fpr, tpr, thresholds = roc_curve(y_train, y_train_predict_prob_pos)

plt.plot([0, 1], [0, 1], linestyle = '--')
plt.plot(fpr, tpr, marker = '*')
plt.xlabel("fpr")
plt.ylabel("tpr")
plt.title('ROC curve of rfcl on training data.')

# rfcl model classification on test set

y_test_predict = rfcl.predict(X_test)
y_test_predict

# rfcl model performance on test set

cm_test = pd.DataFrame(confusion_matrix(y_test, y_test_predict), columns = [0, 1], index = [0, 1])
cm_test

print(classification_report(y_test, y_test_predict))

y_test_predict_prob = rfcl.predict_proba(X_test)
y_test_predict_prob_pos = y_test_predict_prob[:, 1]
roc_score_test = roc_auc_score(y_test, y_test_predict_prob_pos)

print(f"roc_auc_score of rfcl on test data: {roc_score_test}")

fpr, tpr, thresholds = roc_curve(y_test, y_test_predict_prob_pos)

plt.plot([0, 1], [0, 1], linestyle = '--')
plt.plot(fpr, tpr, marker = '*')
plt.xlabel("fpr")
plt.ylabel("tpr")
plt.title("ROC curve of rfcl on test data.")

"""**Training Set Performance:**
1. The RandomForest classifier model achieves an accuracy of 1.00 on the training set.
2. Metrics for exceptional both Class 0 (precision=1.00, recall=1.00, F1-score=1.00) and Class 1 (precision=1.00, recall=1.00, F1-score=1.00).
3. The ROC AUC score is 1.00, demonstrating exceptional predictive power.

**Test Set Performance:**
1. On the test set, the accuracy drops to 0.75 .
2. Class 0 metrics are weak (precision=0.61, recall=0.70, F1-score=0.65), while class 1 metrics are strong (precision=0.84, recall=0.77, F1-score=0.80).
3. The ROC AUC score is 0.84, demonstrating strong predictive power.

**Analysis:** The RandomForest classifier exhibits overfitting and shows a drop in performance on the test set, particularly for class 0, indicating potential overfitting and challenges in handling imbalanced data and requires extensive tuning to generalize well.

**Regularized rfcl classifier**
"""

# Regularized rfcl classifier

reg_rfcl = RandomForestClassifier(n_estimators = 50, criterion = 'gini', max_depth = 10, min_samples_leaf = 100, min_samples_split = 150, max_features = 'sqrt', oob_score = False, random_state = 1)
reg_rfcl.fit(X_train, y_train)

# reg_rfcl prediction on train data

y_train_predict = reg_rfcl.predict(X_train)
y_train_predict

# reg_rfcl performance on train data

cm_train = pd.DataFrame(confusion_matrix(y_train, y_train_predict), columns = ['0', '1'], index = ['0', '1'])
cm_train

print(classification_report(y_train, y_train_predict))

y_train_predict_prob = reg_rfcl.predict_proba(X_train)
y_train_predict_prob_pos = y_train_predict_prob[:, 1]
roc_score = roc_auc_score(y_train, y_train_predict_prob_pos)

print('roc_auc_score of reg_rfcl on train data: {}'.format(roc_score))

fpr, tpr, thresholds = roc_curve(y_train, y_train_predict_prob_pos)

plt.plot([0, 1], [0, 1], linestyle = '--')
plt.plot(fpr, tpr, marker = '*')
plt.xlabel("fpr")
plt.ylabel("tpr")
plt.title("ROC curve of reg_rfcl on training data.")

# reg_rfcl prediction on test data

y_test_predict = reg_rfcl.predict(X_test)

# reg_rfcl_model performance on test data

cm_test = pd.DataFrame(confusion_matrix(y_test, y_test_predict), columns = ['0', '1'], index = ['0', '1'])
cm_test

print(classification_report(y_test, y_test_predict))

y_test_predict_prob = reg_rfcl.predict_proba(X_test)
y_test_predict_prob_pos = y_test_predict_prob[:, 1]
roc_score = roc_auc_score(y_test, y_test_predict_prob_pos)

print('roc_auc_score of reg_rfcl on test data: {}'.format(roc_score))

fpr, tpr, thresholds = roc_curve(y_test, y_test_predict_prob_pos)

plt.plot([0, 1], [0, 1], linestyle = '--')
plt.plot(fpr, tpr, marker = '*')
plt.xlabel("fpr")
plt.ylabel("tpr")
plt.title("ROC curve of reg_rfcl on test data.")

"""**Training Set Performance:**
1. The regularized RandomForest classifier model achieves an accuracy of 0.77 on the training set.
2. Class 0 metrics are weak (precision=0.65, recall=0.68, F1-score=0.66), while Class 1 metrics are robust (precision=0.83, recall=0.81, F1-score=0.82),
3. The ROC AUC score is 0.86, demonstrating strong predictive power.

**Test Set Performance:**
1. On the test set, the accuracy remains steady at 0.74 .
2. Class 0 metrics are weak (precision=0.61, recall=0.65, F1-score=0.63), while class 1 metrics are robust (precision=0.82, recall=0.79, F1-score=0.80).
3. The ROC AUC score is 0.84, demonstrating strong predictive power.

**Analysis:** The regularized RandomForest classifier maintains consistent performance across training and test sets, suggesting good generalization capabilities. Performance of Class 0 is weak in both train and test set indicating challenges in handling imbalanced data.

**Model with best performance -**

---



* Based on the provided text, the regularized RandomForest classifier appears to be the better-optimized model.
* It maintains consistent performance across both training and test datasets, suggesting good generalization capabilities.
* While the original RandomForest classifier and DecisionTree classifier models achieved perfect accuracy on the training set (indicating overfitting), their performance dropped on the test set.
* The regularized models, both Decision Tree and Random Forest, show more balanced performance, with the regularized Random Forest achieving a higher ROC AUC score (0.84) on the test data compared to the regularized Decision Tree (0.83).
"""

