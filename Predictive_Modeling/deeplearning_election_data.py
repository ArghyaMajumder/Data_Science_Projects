# -*- coding: utf-8 -*-
"""DeepLearning_Election_Data.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15sjR5zM5xfl7SSzVetYk9Y9DBTDSIsEC
"""

from google.colab import files

uploaded = files.upload()

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np

import seaborn as sns
import matplotlib.pyplot as plt
# %matplotlib inline

from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix, classification_report, roc_auc_score, roc_curve

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout
from tensorflow.keras.callbacks import EarlyStopping

election_df = pd.read_excel('Election_Data.xlsx', sheet_name = 'Election_Dataset_Two Classes')
election_df.head(10)

election_df.info()

"""* Out of **10 columns** in election_df, **8 columns are of integer datatype and 2 columns are of object datatype**"""

election_df.isnull().sum()

"""* election_df doesn't contain missing data."""

election_df[election_df.duplicated()]

"""* election_df doesn't contain any duplicate data point(row)."""

# Since 'Unnamed: 0' column is of no significance, hence 'Unnamed: 0' is being removed from election_df

election_df.drop('Unnamed: 0', axis = 1, inplace = True)
election_df.head()

"""**Exploratory Data Analysis**"""

print('Number of parties contesting the election are {} and they are {}\n'.format(election_df['vote'].nunique(), election_df['vote'].unique()))

print('Votes each party secured are as follows {}-\n'.format(election_df['vote'].value_counts()))

print('Votes each party secured in % are as follows {}-\n'.format(election_df['vote'].value_counts(normalize = True)))

plt.figure(figsize = (3, 4))
sns.displot(x = 'vote', data = election_df, kind = 'hist')
plt.title('Histplot showing the distribution of votes secured by the contesting parties.')

"""* The election data involves two parties, **Labour** and **Conservative, with Labour securing approximately 70% of the votes (1063 votes) and Conservative securing 30% (462 votes)**."""

print('The voters in election_df are of age-\n{}\n'.format(election_df['age'].unique()))

print('Number of voters of different age groups-\n{}\n'.format(election_df['age'].value_counts()))

print('Percentage of voters of different age groups-\n{}\n'.format(election_df['age'].value_counts(normalize = True)))

plt.figure(figsize = (35, 6))
sns.countplot(x = 'age', data = election_df)
plt.grid()
plt.title('Countplot showing the number of voters of different age.')

plt.figure(figsize = (45, 10))
sns.countplot(x = 'age', data = election_df, hue = 'vote')
plt.grid()
plt.title('Number of voters of all age who voted for the Conservative and Labour.')

"""* Voter ages range from 24 to 93, with varying numbers of voters in each age group.

* The majority of voters, except those aged 90, 92, and 93, had voted for the Labour Party.

* Voters aged 90, 92, & 93 had voted for the Conservative party.
"""

print('Number of male and female voters in election_df are-\n{}\n'.format(election_df['gender'].value_counts()))

print('Percentage of male and female voters in election_df are-\n{}\n'.format(election_df['gender'].value_counts(normalize = True)))

plt.figure(figsize = (4, 3))
sns.countplot(x = 'gender', data = election_df)
plt.title("Number of male and female voters in election_df.")

plt.figure(figsize = (8, 3))
sns.countplot(x = 'gender', data = election_df, hue = 'vote')
plt.title("Number of male and female voters who voted for the Conservative and Labour party.")

"""* The election data includes both male and female voters, with **females comprising 53.25% and males 46.75% of the electorate.**

* **The majority of both male and female voters supported the Labour Party;** however, **the majority of voters who voted for the Conservative party are female voters**.
"""

#Assessment of current national economic condition

print('The assessment of the current national economic condition by the voters are as follows-\n{}\n'.format(election_df['economic.cond.national'].value_counts()))

print('The assessment of the current national economic condition by the voters in percentage are as follows-\n{}\n'.format(election_df['economic.cond.national'].value_counts(normalize = 1)))

plt.figure(figsize = (8, 4))
sns.countplot(x = 'economic.cond.national', data = election_df)
plt.title('Assessment of current national economic contition by the voters')

plt.figure(figsize = (8, 4))
sns.countplot(x = 'economic.cond.national', data = election_df, hue = 'vote')
plt.title('Assessment of current national economic contition by the voters and the party they voted')

"""* The majority of voters with a strong assessment of the national economic condition voted for the Labour Party, while those with a weak assessment favored the Conservative Party."""

#Assessment of current household economic condition

print('The assessment of the current household economic condition by the voters are as follows-\n{}\n'.format(election_df['economic.cond.household'].value_counts()))

print('The assessment of the current household economic condition by the voters in percentage are as follows-\n{}\n'.format(election_df['economic.cond.household'].value_counts(normalize = 1)))

plt.figure(figsize = (8, 4))
sns.countplot(x = 'economic.cond.household', data = election_df)
plt.title('Assessment of current household economic contition by the voters')

plt.figure(figsize = (8, 4))
sns.countplot(x = 'economic.cond.household', data = election_df, hue = 'vote')
plt.title('Assessment of current household economic contition by the voters and the party they voted')

"""* The majority of voters, regardless of their household economic assessment, voted for the Labour Party, suggesting that household economic conditions were not a strong determinant in vote choice."""

#Assessment of the Labour leader

print('The assessment of the Labour leader by the voters are as follows-\n{}\n'.format(election_df['Blair'].value_counts()))

print('The assessment of the Labour leader by the voters in percentage are as follows-\n{}\n'.format(election_df['Blair'].value_counts(normalize = 1)))

plt.figure(figsize = (8, 4))
sns.countplot(x = 'Blair', data = election_df)
plt.title('Assessment of the Labour party leader by the voters')

plt.figure(figsize = (8, 4))
sns.countplot(x = 'Blair', data = election_df, hue = 'vote')
plt.title('Assessment of the Labour party leader by the voters and the party they voted')

"""* A strong assessment of the Labour leader correlated with votes for the Labour party"""

#Assessment of the Conservative leader

print('The assessment of the Conservative leader by the voters are as follows-\n{}\n'.format(election_df['Hague'].value_counts()))

print('The assessment of the Conservative leader by the voters in percentage are as follows-\n{}\n'.format(election_df['Hague'].value_counts(normalize = 1)))

plt.figure(figsize = (8, 4))
sns.countplot(x = 'Hague', data = election_df)
plt.title('Assessment of the Conservative party leader by the voters')

plt.figure(figsize = (8, 4))
sns.countplot(x = 'Hague', data = election_df, hue = 'vote')
plt.title('Assessment of the Conservative party leader by the voters and the party they voted')

"""* A weak assessment correlated with votes for the Conservative party."""

#Voters attitude toward European integration

print('The assessment of the voters attitude toward European integration are as follows-\n{}\n'.format(election_df['Europe'].value_counts()))

print('The assessment of the voters attitude toward European integration in percentage are as follows-\n{}\n'.format(election_df['Europe'].value_counts(normalize = 1)))

plt.figure(figsize = (8, 4))
sns.countplot(x = 'Europe', data = election_df)
plt.title('Assessment of the voters attitude toward European integration')

plt.figure(figsize = (8, 4))
sns.countplot(x = 'Europe', data = election_df, hue = 'vote')
plt.title('Assessment of the voters attitude toward European integration and the party they voted')

"""* Voters who rated European integration from 1 to 8 mostly voted for Labour, while those who rated it from 9 to 11 favored the Conservative party."""

# Knowledge of parties positions on European integration

print('Voters knowledge of parties position on European integration-\n{}\n'.format(election_df['political.knowledge'].value_counts()))

print('Voters knowledge of parties position on European integration in percentage are as follows-\n{}\n'.format(election_df['political.knowledge'].value_counts(normalize = 1)))

plt.figure(figsize = (6, 4))
sns.countplot(x = 'political.knowledge', data = election_df)
plt.title('Voters knowledge of parties position on European integration')

plt.figure(figsize = (6, 4))
sns.countplot(x = 'political.knowledge', data = election_df, hue = 'vote')
plt.title('Voters knowledge of parties position on European integration and the party they voted')

"""* The majority of voters, regardless of their political knowledge, voted for the Labour Party, suggesting that political knowledge is not a strong determinant in vote choice ."""

# Descriptive statistics of election_df

election_df.describe()

plt.figure(figsize = (10, 4))
sns.heatmap(election_df[['age', 'economic.cond.national', 'economic.cond.household', 'Blair', 'Hague', 'Europe', 'political.knowledge']].corr(), annot = True)

for col in election_df.columns:
  if election_df[col].dtype == 'object':
    print('feature: ', col)
    print(pd.Categorical(election_df[col].unique()))
    print(pd.Categorical(election_df[col].unique()).codes)
    election_df[col] = pd.Categorical(election_df[col]).codes
    print('\n')

election_df.info()

X = election_df.drop('vote', axis = 1).values
y = election_df['vote'].values

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.3, random_state = 11)

sscaler = StandardScaler()

X_train = sscaler.fit_transform(X_train)
X_test = sscaler.transform(X_test)

X_train

X_test

"""**DeepLearning model**"""

dd_model = Sequential()

# Input
dd_model.add(Dense(512, activation = 'relu', input_dim = X_train.shape[1]))
dd_model.add(Dropout(0.25))

# Hidden
dd_model.add(Dense(256, activation = 'relu'))
dd_model.add(Dropout(0.25))

dd_model.add(Dense(128, activation = 'relu'))
dd_model.add(Dropout(0.25))

dd_model.add(Dense(64, activation = 'relu'))
dd_model.add(Dropout(0.25))

dd_model.add(Dense(32, activation = 'relu'))
dd_model.add(Dropout(0.25))

dd_model.add(Dense(16, activation = 'relu'))
dd_model.add(Dropout(0.25))

dd_model.add(Dense(8, activation = 'relu'))
dd_model.add(Dropout(0.25))

# Output
dd_model.add(Dense(1, activation = 'sigmoid'))

# Compilation
dd_model.compile(optimizer = 'adam', loss = 'binary_crossentropy')

early_stop = EarlyStopping(monitor = 'val_loss', mode = 'min', verbose = 1, patience = 25)

dd_model.fit(X_train, y_train, validation_data = (X_test, y_test), epochs = 300, callbacks = early_stop, verbose = 1)

dd_model_loss = pd.DataFrame(dd_model.history.history)
dd_model_loss

plt.figure(figsize = (7, 4))
dd_model_loss.plot()
plt.xlabel('epochs')
plt.ylabel('loss')
plt.title('Loss on train & validation set')
plt.show()

# Prediction on train data

y_train_predict_prob = dd_model.predict(X_train)

threshold = 0.50

y_train_predict = (y_train_predict_prob >= threshold).astype(int)
y_train_predict

# Confusion matrix on train set

cm_train = pd.DataFrame(confusion_matrix(y_train, y_train_predict))
cm_train

# Classification report on train data

print(classification_report(y_train, y_train_predict))

# roc_auc_score on train data

roc_score_train = roc_auc_score(y_train, y_train_predict_prob)
print(f"roc_auc_score on train data : {roc_score_train}")

# roc curve on train data

fpr, tpr, threshold = roc_curve(y_train, y_train_predict_prob)

plt.figure(figsize = (7, 4))
plt.plot([0, 1], [0, 1], linestyle = '--')
plt.plot(fpr, tpr, marker = '*')
plt.xlabel('fpr')
plt.ylabel('tpr')
plt.title('roc_curve of dd_model on train data')
plt.show()

# Prediction on test data

y_test_predict_prob = dd_model.predict(X_test)

threshold = 0.50

y_test_predict = (y_test_predict_prob >= threshold).astype(int)
y_test_predict

# Confusion matrix on test data

cm_test = pd.DataFrame(confusion_matrix(y_test, y_test_predict))
cm_test

# Classification report on test data

print(classification_report(y_test, y_test_predict))

# roc_auc_score on test data

roc_score_test = roc_auc_score(y_test, y_test_predict_prob)
print(f"roc_auc_score on test data : {roc_score_test}")

# roc curve on test data

fpr, tpr, threshold = roc_curve(y_test, y_test_predict_prob)

plt.figure(figsize = (7, 4))
plt.plot([0, 1], [0, 1], linestyle = '--')
plt.plot(fpr, tpr, marker = '*')
plt.xlabel('fpr')
plt.ylabel('tpr')
plt.title('roc_curve of dd_model on test data')
plt.show()

"""**Training Set Performance:**
1. The DeepLearning model achieves an accuracy of 0.90 on the training set.
2. Class 0 metrics are robust (precision=0.83, recall=0.82, F1-score=0.82), while Class 1 metrics are outstanding (precision=0.92, recall=0.93, F1-score=0.93).
3. The ROC AUC score is 0.96, demonstrating strong predictive power.

**Test Set Performance:**
1. On the test set, the accuracy remains steady at 0.83 .
2. Class 0 metrics are moderate (precision=0.72, recall=0.71, F1-score=0.71), while class 1 metrics are robust (precision=0.87, recall=0.88, F1-score=0.87).
3. The ROC AUC score is 0.89, demonstrating strong predictive power.

**Analysis:** The DeepLearning  maintains consistent performance across training and test sets, suggesting good generalization capabilities. There is a drop in performance on the test set, particularly for class 0, indicating potential challenges in handling imbalanced data.
"""

